# Addition of 'App Instance ID' and 'Core Instance ID'

* Proposal: [SDL-0142](0142-mt-instance-ids.md)
* Author: [Sho Amano](https://github.com/shoamano83), [Robin Kurian](https://github.com/robinmk)
* Status: **Returned for Revisions**
* Impacted Platforms: [Core / iOS / Android / Protocol / BSON library]

## Introduction

This document proposes to include two IDs in the payload of Start Service and Start Service ACK frames during Version Negotiation. This is a sub-proposal of [SDL-nnnn: Supporting simultaneous multiple transports][multiple_transports].


## Motivation

To support multiple transports between Core and Proxy, Core needs to distinguish between the cases "a single SDL app connecting to SDL Core using two different transports" and "two instances of a SDL app on two phones connecting to SDL Core using different transports". Also, Proxy needs to make sure that it is not connected to different head units at the same time.

An idea of distinguishing between phones is to use device-specific information, such as MAC address of Wi-Fi hardware or Unique Device Identifier of iPhone. When connecting to SDL Core, Proxy notifies such information every time. When a single ID is notified from multiple transports, Core treats them as connections from a single device. The problem with this approach is that mobile apps are prohibited to acquire such device-unique ID on recent OSes due to privacy concerns.

In this document, an ID that is unique to application instance is proposed instead. The ID is called "App Instance ID". Similarly, "Core Instance ID" which is unique to SDL Core instance is proposed. These IDs are exchanged between Proxy and Core after a transport is connected.


## Proposed solution

### Specification of "App Instance ID"

When connecting to Core, Proxy generates an ID. The ID should be unique enough so that it will not collide with IDs generated by other apps on the phone, or other apps on another phone that are already connected to the Core. Proxy must use same ID until all transports are disconnected from the Core.

Proxy may generate another instance ID after all transports are disconnected. Due to this nature, Core must not use this ID to know whether same app is reconnected.

For App Instance ID, this document proposes to employ Universally Unique Identifier (UUID) version 4, which is a 122-bit value generated randomly. On iOS and Android, generating this ID requires no additional permission nor library dependencies.

For the specification of UUID version 4, please refer to section 4.4 of [RFC 4122][rfc4122].

### Specification of "Core Instance ID"

When Core is started, it creates an instance ID. The ID should be unique enough so that it will not collide with IDs generated by another Core on another head unit. Core must use same ID until it is terminated (usually, until ignition off.)

After ignition off and on, Core may regenerate another ID. Due to this nature, Proxy must not use this ID to know whether it is re-connecting to same head unit after all transports have been disconnected.

For Core Instance ID, this document proposes to employ UUID version 4. Note that to generate a truly random ID, a head unit system should have enough entropy available. Thus, it is recommended that the system saves its entropy state after ignition off, and recovers it after ignition on.

See "Alternative Considered" section for ideas using other versions of UUID.

### Exchanging IDs

App Instance ID and Core Instance ID are exchanged between Proxy and Core during Version Negotiation procedure.

Proxy includes its App Instance ID in the payload of Start Service frame of RPC service. When starting RPC services over multiple transports, it must include the same ID in every Start Service frame.

When Core receives a Start Service frame including App Instance ID, it includes its Core Instance ID in the Start Service ACK frame of RPC service.

Old versions of Core do not include a Core Instance ID in Start Service ACK frame. Proxy may use this fact to distinguish if Core supports multiple-transports feature.

A proxy that does not intend to use multiple transports may omit App Instance ID in Start Service frame of RPC service.


## Detailed design

### Extension of SDL Protocol

Add a parameter called `appInstanceId` in the Start Service frame of RPC service:

Tag Name      | Type                               | Description
--------------|------------------------------------|------------
appInstanceId | binary <br> (subtype: "\x04" UUID) | (Optional) An UUID value representing the instance of this app. SDL Core uses this value to distinguish whether a single Proxy initiates multiple transports. <br> A proxy that does not intend to use multiple transports can omit this parameter.

Add a parameter called `coreInstanceId` in the Start Service ACK frame of RPC service.

Tag Name       | Type                               | Description
---------------|------------------------------------|------------
coreInstanceId | binary <br> (subtype: "\x04" UUID) | (Optional) An UUID value representing the instance of Core. SDL Proxy uses this value to verify whether it connects to a single instance of Core through multiple transports. <br> This value should be included only when corresponding StartService frame includes `appInstanceId` parameter. <br> Old versions of Core do not include this parameter. Proxy may use this fact to distinguish if Core supports multiple-transports feature.

Also 'Minor' field of the Protocol version should be updated.


### Extension of iOS Proxy

iOS Proxy generates an App Instance ID (UUID version 4) using following code:

```objc
uuid_t uuid;  // this is actually 16-byte array of unsigned chars
[[NSUUID UUID] getUUIDBytes:uuid];
```

`SDLProtocol` and related classes are updated to include App Instance ID in Start Service frame and receive Core Instance ID in Start Service ACK frame of RPC service.


### Extension of Android Proxy

Android Proxy generates an App Instance ID (UUID version 4) using following code:

```java
UUID uuid = UUID.randomUUID();
ByteBuffer buffer = ByteBuffer.allocate(16);
buffer.putLong(uuid.getMostSignificantBits());
buffer.putLong(uuid.getLeastSignificantBits());
buffer.flip();

// creates a byte array representation of the UUID
byte[] output = new byte[16];
buffer.get(output);
```

`WiProProtocol` and related classes are updated to include App Instance ID in Start Service frame and receive Core Instance ID in Start Service ACK frame of RPC service.


### Extension of Core

Generating a version-4 UUID should be fairly straightforward as we read 16 bytes from `/dev/urandom` and update some bits to conform with the format. Alternatively, [libuuid][libuuid] can be linked and used, whose license is Modified BSD License.

`ProtocolHandlerImpl` and related classes are updated to receive App Instance ID in Start Service frame and include Core Instance ID in Start Service ACK frame of RPC service.

### Extension of BSON library

Add support of type `TYPE_BINARY` (0x05).


## Potential downsides

Starting time of Core will get slightly longer to generate an UUID value. Also, Proxy will take additional time to generate an UUID value when starting transports.


## Impact on existing code

Code changes should be limited to Protocol handler components of Core and Proxy. UUID generation will be done in newly added classes. (Please refer to [SDL-nnnn][multiple_transports].)


## Alternatives considered

* Using a device-specific ID instead of "App Instance ID". As already described, acquiring such ID in mobile app is restricted in recent OSes. See appendix for the list of IDs that have been considered.
* Reusing 'Hash ID' instead of adding App Instance ID. This approach should also work, however it should be noted that:
  - The Hash ID can be updated while the app is running. There is a chance of timing issue where Proxy sends an old value of Hash ID and Core sends updated Hash ID at the same time, which will result that Core cannot recognize multiple transports coming from a single app.
  - Since Hash ID is included in RegisterAppInterface request, this approach impacts implementation in ApplicationManager layer rather than Protocol layer.
* Using UUID Version 1 (UTC + MAC address) for Core Instance ID.
  - Advantage: this approach will not require high-quality random generator
  - Disadvantage: this approach requires three things compared to Version 4:
    1. current time. Concern is that some embedded systems may take some time to acquire current time after ignition on (e.g. to receive GPS time).
    2. MAC address, either Wi-Fi or Bluetooth
    3. file system to store clock sequence and last timestamp
* Using UUID Version 5 (name-based UUID) for Core Instance ID and employ ISO VIN code as the names.
  - Advantage: this approach generates truly unique IDs (provided that there is no duplicate VINs on earth)
  - Disadvantages: Core needs to acquire VIN from HMI before starting transports.<br>
    There may be a privacy concern as generated UUID has no randomness. An attacker might be able to obtain VIN from Core Instance ID by calculating hashes of all possible VINs offline.
* Exchanging the IDs through RegisterAppInterface request and response instead of Version Negotiation. As noted in [SDL-nnnn][multiple_transports], this approach has more impact on implementations since ApplicationManager layers of SDL Core and Proxies need to be updated.
* Instead of Proxy generating App Instance ID, Core generates it and notifies it to Proxy when the first transport is connected. The advantage of this idea is that Core can regenerate App Instance ID if it collides with previously generated one. However, Core will consume more and more RAM as it needs to remember all IDs that have been generated.
* Putting App Instance ID and Core Instance ID as strings in Start Service and Start Service ACK frames, rather than binary format. With this approach, bson\_c\_lib does not need to be updated. On the other hand, it slightly increases implementation in Proxies and Core (i.e. conversion from array to string and vice versa).


## Appendix: list of IDs that have been considered

- IP address - This is available only when the phone is connected to a Wi-Fi network, and it may be updated with reconnection. If we use this as an ID, we need to consider a mechanism to update the ID while SDL is running, and the protocol will become more complex.
- MAC addresses (Wi-Fi or Bluetooth) - not available on iOS 7 / Android 6 and later.
- IMEI (International Mobile Equipment Identity) - This is not available on iOS 4 and later. On Android, READ\_PHONE\_STATE permission is required.
- ICCID (IC Card Identifier) and IMSI (International Mobile Subscriber Identity) - Not available on iPhone.
- UDID (Unique Device Identifier) - iOS specific. An app that accesses this ID is rejected by Apple.
- identifierForVendor property of UIDevice - iOS specific. The issue with this ID is that it is shared between apps from same vendor. We need to combine it with some kinds of app's ID (such as bundle ID) to make it application-specific.
- advertisingIdentifier property of ASIdentifierManager - iOS Specific. This is not suitable for our purpose as it is intended for advertisements. Also note that the phone's user can disable this feature.
- Android ID - Android specific. This is still available, however [an entry of Android developer's blog][androido] suggests that *"Developers requiring a device-scoped identifier, should instead use a resettable identifier, such as Advertising ID, giving users more control."*
- Advertising ID - Android specific. This is not suitable for our purpose as it is primarily intended for advertisements. Also, this introduces a dependency on Google Play Services.


## References

- [RFC 4122: A Universally Unique IDentifier (UUID) URN Namespace][rfc4122]
- [libuuid source code (part of util-linux package)][libuuid]
- [Changes to Device Identifiers in Android O][androido]
- [SDL-nnnn: Supporting simultaneous multiple transports][multiple_transports] (Parent proposal)


  [rfc4122]:             https://tools.ietf.org/html/rfc4122  "A Universally Unique IDentifier (UUID) URN Namespace"
  [libuuid]:             https://git.kernel.org/pub/scm/utils/util-linux/util-linux.git/tree/libuuid  "libuuid source code (part of util-linux package)"
  [androido]:            https://android-developers.googleblog.com/2017/04/changes-to-device-identifiers-in.html  "Changes to Device Identifiers in Android O"
  [multiple_transports]: nnnn-multiple-transports.md  "Supporting simultaneous multiple transports"

